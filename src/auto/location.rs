// This file was generated by gir (https://github.com/gtk-rs/gir)
// from 
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::LocationLevel;
use glib::object::IsA;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::ptr;

glib::wrapper! {
    #[doc(alias = "GWeatherLocation")]
    pub struct Location(Object<ffi::GWeatherLocation, ffi::GWeatherLocationClass>);

    match fn {
        type_ => || ffi::gweather_location_get_type(),
    }
}

impl Location {
    /// Construct a new location from the given data, supplementing
    /// any missing information from the static database.
    /// ## `name`
    /// the user visible location name
    /// ## `icao`
    /// the ICAO code of the location
    /// ## `latitude`
    /// the latitude of the location
    /// ## `longitude`
    /// the longitude of the location
    ///
    /// # Returns
    ///
    /// the newly created detached location
    #[doc(alias = "gweather_location_new_detached")]
    pub fn new_detached(name: &str, icao: Option<&str>, latitude: f64, longitude: f64) -> Location {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gweather_location_new_detached(name.to_glib_none().0, icao.to_glib_none().0, latitude, longitude))
        }
    }

    /// This call undoes the effect of gweather_location_serialize(), that
    /// is, it turns a #GVariant into a #GWeatherLocation. The conversion
    /// happens in the context of @self (i.e, for a city or weather station,
    /// the resulting location will be attached to a administrative division,
    /// country and region as appropriate).
    /// ## `serialized`
    /// the #GVariant representing the #GWeatherLocation
    ///
    /// # Returns
    ///
    /// the deserialized location.
    #[doc(alias = "gweather_location_deserialize")]
#[must_use]
    pub fn deserialize(&self, serialized: &glib::Variant) -> Location {
        unsafe {
            from_glib_full(ffi::gweather_location_deserialize(self.to_glib_none().0, serialized.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_equal")]
    pub fn equal(&self, two: &Location) -> bool {
        unsafe {
            from_glib(ffi::gweather_location_equal(self.to_glib_none().0, two.to_glib_none().0))
        }
    }

    /// Retrieves the country identified by the specified ISO 3166 code,
    /// if present in the database.
    /// ## `country_code`
    /// a country code
    ///
    /// # Returns
    ///
    /// a country level #GWeatherLocation, or [`None`].
    #[doc(alias = "gweather_location_find_by_country_code")]
#[must_use]
    pub fn find_by_country_code(&self, country_code: &str) -> Location {
        unsafe {
            from_glib_full(ffi::gweather_location_find_by_country_code(self.to_glib_none().0, country_code.to_glib_none().0))
        }
    }

    /// Retrieves the weather station identifier by @station_code.
    ///
    /// Note that multiple instances of the same weather station can exist
    /// in the database, and this function will return any of them, so this
    /// not usually what you want.
    ///
    /// See [`deserialize()`][Self::deserialize()] to recover a stored location.
    /// ## `station_code`
    /// a 4 letter METAR code
    ///
    /// # Returns
    ///
    /// a weather station level location
    ///   for the given station code, or `NULL` if none exists in the database
    #[doc(alias = "gweather_location_find_by_station_code")]
#[must_use]
    pub fn find_by_station_code(&self, station_code: &str) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_find_by_station_code(self.to_glib_none().0, station_code.to_glib_none().0))
        }
    }

    /// Finds the nearest city to the passed latitude and
    /// longitude, among the descendants of @self.
    ///
    /// The given location must be at most a [`LocationLevel::Adm1`][crate::LocationLevel::Adm1] location.
    /// This restriction may be lifted in a future version.
    ///
    /// Note that this function does not check if (@lat, @lon) fall inside
    /// @self, or are in the same region and time zone as the return value.
    /// ## `lat`
    /// Latitude, in degrees
    /// ## `lon`
    /// Longitude, in degrees
    ///
    /// # Returns
    ///
    /// the city closest to (@lat, @lon), in the
    ///   region or administrative district of @self.
    #[doc(alias = "gweather_location_find_nearest_city")]
#[must_use]
    pub fn find_nearest_city(&self, lat: f64, lon: f64) -> Location {
        unsafe {
            from_glib_full(ffi::gweather_location_find_nearest_city(self.to_glib_none().0, lat, lon))
        }
    }

    /// Finds the nearest city to the passed latitude and
    /// longitude, among the descendants of @self.
    ///
    /// Supports the use of own filter function to filter out locations.
    ///
    /// Geocoding should be done on the application side if needed.
    ///
    /// @self must be at most a [`LocationLevel::Adm1`][crate::LocationLevel::Adm1] location.
    /// This restriction may be lifted in a future version.
    /// ## `lat`
    /// Latitude, in degrees
    /// ## `lon`
    /// Longitude, in degrees
    /// ## `func`
    /// a function to iterate
    ///   over the locations; the function must return `TRUE` to continue checking
    ///   for the location, and `FALSE` to filter the location out
    ///
    /// # Returns
    ///
    /// the city closest to (@lat, @lon), in the
    ///   region or administrative district of @self with validation of
    ///   filter function
    #[doc(alias = "gweather_location_find_nearest_city_full")]
#[must_use]
    pub fn find_nearest_city_full(&self, lat: f64, lon: f64, func: Option<Box_<dyn Fn(&Location) -> bool + 'static>>) -> Location {
        let func_data: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = Box_::new(func);
        unsafe extern "C" fn func_func(location: *mut ffi::GWeatherLocation, user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let location = from_glib_borrow(location);
            let callback: &Option<Box_<dyn Fn(&Location) -> bool + 'static>> = &*(user_data as *mut _);
            let res = if let Some(ref callback) = *callback {
                callback(&location)
            } else {
                panic!("cannot get closure...")
            };
            res.into_glib()
        }
        let func = if func_data.is_some() { Some(func_func as _) } else { None };
        unsafe extern "C" fn destroy_func(data: glib::ffi::gpointer) {
            let _callback: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = Box_::from_raw(data as *mut _);
        }
        let destroy_call5 = Some(destroy_func as _);
        let super_callback0: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = func_data;
        unsafe {
            from_glib_full(ffi::gweather_location_find_nearest_city_full(self.to_glib_none().0, lat, lon, func, Box_::into_raw(super_callback0) as *mut _, destroy_call5))
        }
    }

    /// Retrieves the city name for the given location.
    ///
    /// For a `GWEATHER_LOCATION_CITY` or `GWEATHER_LOCATION_DETACHED` location,
    /// this method is equivalent to [`name()`][Self::name()].
    ///
    /// For a `GWEATHER_LOCATION_WEATHER_STATION` location, this is equivalent to
    /// calling [`name()`][Self::name()] on the location's parent.
    ///
    /// For other locations this method will return `NULL`.
    ///
    /// # Returns
    ///
    /// the city name of the location
    #[doc(alias = "gweather_location_get_city_name")]
    #[doc(alias = "get_city_name")]
    pub fn city_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_city_name(self.to_glib_none().0))
        }
    }

    /// Gets the METAR station code associated with a
    /// `GWEATHER_LOCATION_WEATHER_STATION` location.
    ///
    /// # Returns
    ///
    /// the location's METAR station code
    #[doc(alias = "gweather_location_get_code")]
    #[doc(alias = "get_code")]
    pub fn code(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_code(self.to_glib_none().0))
        }
    }

    /// Gets @self's coordinates.
    ///
    /// You must call [`has_coords()`][Self::has_coords()] before calling
    /// this function.
    ///
    /// # Returns
    ///
    ///
    /// ## `latitude`
    /// the return location for the latitude
    ///
    /// ## `longitude`
    /// the return location for the longitude
    #[doc(alias = "gweather_location_get_coords")]
    #[doc(alias = "get_coords")]
    pub fn coords(&self) -> (f64, f64) {
        unsafe {
            let mut latitude = mem::MaybeUninit::uninit();
            let mut longitude = mem::MaybeUninit::uninit();
            ffi::gweather_location_get_coords(self.to_glib_none().0, latitude.as_mut_ptr(), longitude.as_mut_ptr());
            (latitude.assume_init(), longitude.assume_init())
        }
    }

    /// Gets the ISO 3166 country code of the given location.
    ///
    /// For `GWEATHER_LOCATION_WORLD` and `GWEATHER_LOCATION_REGION`, this
    /// function returns `NULL`.
    ///
    /// # Returns
    ///
    /// the location's country code
    #[doc(alias = "gweather_location_get_country")]
    #[doc(alias = "get_country")]
    pub fn country(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_country(self.to_glib_none().0))
        }
    }

    /// Retrieves the country name for the given location.
    ///
    /// For a `GWEATHER_LOCATION_COUNTRY` location, this is equivalent to
    /// [`name()`][Self::name()].
    ///
    /// For a `GWEATHER_LOCATION_REGION` and `GWEATHER_LOCATION_WORLD` location,
    /// this method will return `NULL`.
    ///
    /// For other location levels, this method will find the parent
    /// `GWEATHER_LOCATION_COUNTRY` and return its name.
    ///
    /// # Returns
    ///
    /// the location's country name
    #[doc(alias = "gweather_location_get_country_name")]
    #[doc(alias = "get_country_name")]
    pub fn country_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_country_name(self.to_glib_none().0))
        }
    }

    /// Determines the distance in kilometers between @self and @loc2.
    /// ## `loc2`
    /// a second #GWeatherLocation
    ///
    /// # Returns
    ///
    /// the distance between @self and @loc2.
    #[doc(alias = "gweather_location_get_distance")]
    #[doc(alias = "get_distance")]
    pub fn distance(&self, loc2: &Location) -> f64 {
        unsafe {
            ffi::gweather_location_get_distance(self.to_glib_none().0, loc2.to_glib_none().0)
        }
    }

    /// Gets the location's name.
    ///
    /// # Returns
    ///
    /// the location's name
    #[doc(alias = "gweather_location_get_english_name")]
    #[doc(alias = "get_english_name")]
    pub fn english_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_english_name(self.to_glib_none().0))
        }
    }

    /// Gets the location's name, in a representation useful for comparisons.
    ///
    /// The "sort name" is the location's name after having g_utf8_normalize()
    /// (with `G_NORMALIZE_ALL`) and g_utf8_casefold() called on it. You can
    /// use this to sort locations, or to comparing user input against a
    /// location name.
    ///
    /// # Returns
    ///
    /// the sort name of the location
    #[doc(alias = "gweather_location_get_english_sort_name")]
    #[doc(alias = "get_english_sort_name")]
    pub fn english_sort_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_english_sort_name(self.to_glib_none().0))
        }
    }

    /// Gets @self's level, from [`LocationLevel::World`][crate::LocationLevel::World], to
    /// [`LocationLevel::WeatherStation`][crate::LocationLevel::WeatherStation].
    ///
    /// # Returns
    ///
    /// @self's level
    #[doc(alias = "gweather_location_get_level")]
    #[doc(alias = "get_level")]
    pub fn level(&self) -> LocationLevel {
        unsafe {
            from_glib(ffi::gweather_location_get_level(self.to_glib_none().0))
        }
    }

    /// Gets the location's name, localized into the current language.
    ///
    /// # Returns
    ///
    /// the location's name
    #[doc(alias = "gweather_location_get_name")]
    #[doc(alias = "get_name")]
    pub fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_name(self.to_glib_none().0))
        }
    }

    /// Gets the location's parent.
    ///
    /// # Returns
    ///
    /// the location's parent
    #[doc(alias = "gweather_location_get_parent")]
    #[doc(alias = "get_parent")]
#[must_use]
    pub fn parent(&self) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_parent(self.to_glib_none().0))
        }
    }

    /// Gets the location's name, localized into the current language,
    /// in a representation useful for comparisons.
    ///
    /// The "sort name" is the location's name after having g_utf8_normalize()
    /// (with `G_NORMALIZE_ALL`) and g_utf8_casefold() called on it. You can
    /// use this to sort locations, or to comparing user input against a
    /// location name.
    ///
    /// # Returns
    ///
    /// the sort name of the location
    #[doc(alias = "gweather_location_get_sort_name")]
    #[doc(alias = "get_sort_name")]
    pub fn sort_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_sort_name(self.to_glib_none().0))
        }
    }

    /// Gets the timezone associated with @self, if known.
    ///
    /// # Returns
    ///
    /// the location's timezone
    #[doc(alias = "gweather_location_get_timezone")]
    #[doc(alias = "get_timezone")]
    pub fn timezone(&self) -> Option<glib::TimeZone> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_timezone(self.to_glib_none().0))
        }
    }

    /// Gets the timezone associated with @self, if known, as a string.
    ///
    /// # Returns
    ///
    /// the location's timezone as
    ///   a string
    #[doc(alias = "gweather_location_get_timezone_str")]
    #[doc(alias = "get_timezone_str")]
    pub fn timezone_str(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_timezone_str(self.to_glib_none().0))
        }
    }

    /// Gets an array of all timezones associated with any location under
    /// @self.
    ///
    /// Use gweather_location_free_timezones() to free this array.
    ///
    /// # Returns
    ///
    /// the timezones
    ///   associated with the location
    #[doc(alias = "gweather_location_get_timezones")]
    #[doc(alias = "get_timezones")]
    pub fn timezones(&self) -> Vec<glib::TimeZone> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::gweather_location_get_timezones(self.to_glib_none().0))
        }
    }

    /// Checks if @self has valid latitude and longitude.
    ///
    /// # Returns
    ///
    /// [`true`] if @self has valid latitude and longitude.
    #[doc(alias = "gweather_location_has_coords")]
    pub fn has_coords(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_location_has_coords(self.to_glib_none().0))
        }
    }

    /// Checks whether the location has a timezone.
    ///
    /// # Returns
    ///
    /// true if the location has a timezone; false otherwise
    #[doc(alias = "gweather_location_has_timezone")]
    pub fn has_timezone(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_location_has_timezone(self.to_glib_none().0))
        }
    }

    /// Allows iterating all children of a location.
    ///
    /// Pass `NULL` to get the first child, and any child to get the next one.
    ///
    /// Note that the reference to @child is taken, meaning iterating all
    /// children is as simple as:
    ///
    /// **⚠️ The following code is in c ⚠️**
    ///
    /// ```c
    ///   g_autoptr (GWeatherLocation) child = NULL;
    ///   while ((child = gweather_location_next_child (location, child)))
    ///     {
    ///        // Do something with child
    ///     }
    /// ```
    /// ## `child`
    /// the next child
    ///
    /// # Returns
    ///
    /// The next child, if one exists
    #[doc(alias = "gweather_location_next_child")]
#[must_use]
    pub fn next_child(&self, child: Option<&Location>) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_next_child(self.to_glib_none().0, child.to_glib_full()))
        }
    }

    /// Transforms a #GWeatherLocation into a #GVariant, in a way that
    /// calling gweather_location_deserialize() will hold an equivalent
    /// #GWeatherLocation.
    /// The resulting variant can then be stored into GSettings or on disk.
    /// This call is only valid for cities, weather stations and detached
    /// locations.
    /// The format of the resulting #GVariant is private to libgweather,
    /// and it is subject to change. You should use the "v" format in GSettings,
    /// to ensure maximum compatibility with future versions of the library.
    ///
    /// # Returns
    ///
    /// the serialization of @location.
    #[doc(alias = "gweather_location_serialize")]
    pub fn serialize(&self) -> glib::Variant {
        unsafe {
            from_glib_none(ffi::gweather_location_serialize(self.to_glib_none().0))
        }
    }

    /// Obtains the shared `GWeatherLocation` of type `GWEATHER_LOCATION_WORLD`,
    /// representing a hierarchy containing all of the locations from the
    /// location data.
    ///
    /// # Returns
    ///
    /// a `GWEATHER_LOCATION_WORLD`
    ///   location, or `NULL` if the locations data could not be found or could
    ///   not be parsed.
    #[doc(alias = "gweather_location_get_world")]
    #[doc(alias = "get_world")]
    pub fn world() -> Option<Location> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gweather_location_get_world())
        }
    }
}

impl fmt::Display for Location {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Location")
    }
}
