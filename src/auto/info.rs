// This file was generated by gir (https://github.com/gtk-rs/gir)
// from 
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ConditionPhenomenon;
use crate::ConditionQualifier;
use crate::DistanceUnit;
use crate::Location;
use crate::MoonLatitude;
use crate::MoonPhase;
use crate::PressureUnit;
use crate::Provider;
use crate::Sky;
use crate::SpeedUnit;
use crate::TemperatureUnit;
use crate::WindDirection;
use glib::object::Cast;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "GWeatherInfo")]
    pub struct Info(Object<ffi::GWeatherInfo, ffi::GWeatherInfoClass>);

    match fn {
        type_ => || ffi::gweather_info_get_type(),
    }
}

impl Info {
    /// Builds a new `GWeatherInfo` that will provide weather information about
    /// the given location.
    ///
    /// In order to retrieve the weather information, you will need to enable
    /// the desired providers and then call [`update()`][Self::update()]. If
    /// you want to be notified of the completion of the weather information
    /// update, you should connect to the `signal::Info::updated`
    /// signal before updating the `GWeatherInfo` instance.
    /// ## `location`
    /// the desidered location
    ///
    /// # Returns
    ///
    /// a new weather information instance
    #[doc(alias = "gweather_info_new")]
    pub fn new(location: Option<&Location>) -> Info {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gweather_info_new(location.to_glib_none().0))
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Info`] objects.
            ///
            /// This method returns an instance of [`InfoBuilder`](crate::builders::InfoBuilder) which can be used to create [`Info`] objects.
            pub fn builder() -> InfoBuilder {
                InfoBuilder::default()
            }
        

    #[doc(alias = "gweather_info_abort")]
    pub fn abort(&self) {
        unsafe {
            ffi::gweather_info_abort(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gweather_info_get_apparent")]
    #[doc(alias = "get_apparent")]
    pub fn apparent(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_apparent(self.to_glib_none().0))
        }
    }

    /// Get the [application ID](https://docs.flatpak.org/en/latest/conventions.html#application-ids)
    /// of the application fetching the weather.
    ///
    /// # Returns
    ///
    /// the application ID
    #[doc(alias = "gweather_info_get_application_id")]
    #[doc(alias = "get_application_id")]
    pub fn application_id(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::gweather_info_get_application_id(self.to_glib_none().0))
        }
    }

    /// Some weather services require the application showing the
    /// data to include an attribution text, possibly including links
    /// to the service website.
    /// This must be shown prominently toghether with the data.
    ///
    /// # Returns
    ///
    /// the required attribution text, in Pango
    ///          markup form, or [`None`] if not required
    #[doc(alias = "gweather_info_get_attribution")]
    #[doc(alias = "get_attribution")]
    pub fn attribution(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::gweather_info_get_attribution(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_conditions")]
    #[doc(alias = "get_conditions")]
    pub fn conditions(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_conditions(self.to_glib_none().0))
        }
    }

    /// Get the contact information of the application fetching the weather.
    ///
    /// # Returns
    ///
    /// the contact information
    #[doc(alias = "gweather_info_get_contact_info")]
    #[doc(alias = "get_contact_info")]
    pub fn contact_info(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::gweather_info_get_contact_info(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_dew")]
    #[doc(alias = "get_dew")]
    pub fn dew(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_dew(self.to_glib_none().0))
        }
    }

    /// Gets the bitmask of enabled #GWeatherProvider weather
    /// providers.
    #[doc(alias = "gweather_info_get_enabled_providers")]
    #[doc(alias = "get_enabled_providers")]
    pub fn enabled_providers(&self) -> Provider {
        unsafe {
            from_glib(ffi::gweather_info_get_enabled_providers(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// list
    /// of GWeatherInfo* objects for the forecast.
    /// The list is owned by the 'info' object thus is alive as long
    /// as the 'info'. The 'update' property is the date/time when the
    /// forecast info is used for.
    #[doc(alias = "gweather_info_get_forecast_list")]
    #[doc(alias = "get_forecast_list")]
    pub fn forecast_list(&self) -> Vec<Info> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::gweather_info_get_forecast_list(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_humidity")]
    #[doc(alias = "get_humidity")]
    pub fn humidity(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_humidity(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_icon_name")]
    #[doc(alias = "get_icon_name")]
    pub fn icon_name(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::gweather_info_get_icon_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_location")]
    #[doc(alias = "get_location")]
    pub fn location(&self) -> Location {
        unsafe {
            from_glib_none(ffi::gweather_info_get_location(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_location_name")]
    #[doc(alias = "get_location_name")]
    pub fn location_name(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_location_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_pressure")]
    #[doc(alias = "get_pressure")]
    pub fn pressure(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_pressure(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_sky")]
    #[doc(alias = "get_sky")]
    pub fn sky(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_sky(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_sunrise")]
    #[doc(alias = "get_sunrise")]
    pub fn sunrise(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_sunrise(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_sunset")]
    #[doc(alias = "get_sunset")]
    pub fn sunset(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_sunset(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_symbolic_icon_name")]
    #[doc(alias = "get_symbolic_icon_name")]
    pub fn symbolic_icon_name(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::gweather_info_get_symbolic_icon_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_temp")]
    #[doc(alias = "get_temp")]
    pub fn temp(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_temp(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_temp_max")]
    #[doc(alias = "get_temp_max")]
    pub fn temp_max(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_temp_max(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_temp_min")]
    #[doc(alias = "get_temp_min")]
    pub fn temp_min(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_temp_min(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_temp_summary")]
    #[doc(alias = "get_temp_summary")]
    pub fn temp_summary(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_temp_summary(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_upcoming_moonphases")]
    #[doc(alias = "get_upcoming_moonphases")]
    pub fn upcoming_moonphases(&self) -> Option<libc::c_long> {
        unsafe {
            let mut phases = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_upcoming_moonphases(self.to_glib_none().0, phases.as_mut_ptr()));
            if ret { Some(phases.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherTemperatureUnit
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the apparent temperature
    #[doc(alias = "gweather_info_get_value_apparent")]
    #[doc(alias = "get_value_apparent")]
    pub fn value_apparent(&self, unit: TemperatureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_apparent(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// Fills out @phenomenon and @qualifier with current weather conditions.
    ///
    /// # Returns
    ///
    /// TRUE is out arguments are valid, FALSE otherwise.
    ///
    /// ## `phenomenon`
    /// a location for a #GWeatherConditionPhenomenon.
    ///
    /// ## `qualifier`
    /// a location for a #GWeatherConditionQualifier.
    #[doc(alias = "gweather_info_get_value_conditions")]
    #[doc(alias = "get_value_conditions")]
    pub fn value_conditions(&self) -> Option<(ConditionPhenomenon, ConditionQualifier)> {
        unsafe {
            let mut phenomenon = mem::MaybeUninit::uninit();
            let mut qualifier = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_conditions(self.to_glib_none().0, phenomenon.as_mut_ptr(), qualifier.as_mut_ptr()));
            if ret { Some((from_glib(phenomenon.assume_init()), from_glib(qualifier.assume_init()))) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherTemperatureUnit
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the dew point
    #[doc(alias = "gweather_info_get_value_dew")]
    #[doc(alias = "get_value_dew")]
    pub fn value_dew(&self, unit: TemperatureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_dew(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the current moon phase
    ///
    /// ## `lat`
    /// the moon declension
    #[doc(alias = "gweather_info_get_value_moonphase")]
    #[doc(alias = "get_value_moonphase")]
    pub fn value_moonphase(&self) -> Option<(MoonPhase, MoonLatitude)> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let mut lat = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_moonphase(self.to_glib_none().0, value.as_mut_ptr(), lat.as_mut_ptr()));
            if ret { Some((value.assume_init(), lat.assume_init())) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherPressureUnit
    ///
    /// # Returns
    ///
    /// TRUE if @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// forecasted pressure, expressed in @unit
    #[doc(alias = "gweather_info_get_value_pressure")]
    #[doc(alias = "get_value_pressure")]
    pub fn value_pressure(&self, unit: PressureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_pressure(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// Fills out @sky with current sky conditions.
    ///
    /// # Returns
    ///
    /// TRUE is @sky is valid, FALSE otherwise.
    ///
    /// ## `sky`
    /// a location for a #GWeatherSky.
    #[doc(alias = "gweather_info_get_value_sky")]
    #[doc(alias = "get_value_sky")]
    pub fn value_sky(&self) -> Option<Sky> {
        unsafe {
            let mut sky = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_sky(self.to_glib_none().0, sky.as_mut_ptr()));
            if ret { Some(from_glib(sky.assume_init())) } else { None }
        }
    }

    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the time of sunrise
    #[doc(alias = "gweather_info_get_value_sunrise")]
    #[doc(alias = "get_value_sunrise")]
    pub fn value_sunrise(&self) -> Option<libc::c_ulong> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_sunrise(self.to_glib_none().0, value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the time of sunset
    #[doc(alias = "gweather_info_get_value_sunset")]
    #[doc(alias = "get_value_sunset")]
    pub fn value_sunset(&self) -> Option<libc::c_ulong> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_sunset(self.to_glib_none().0, value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherTemperatureUnit
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the temperature value
    #[doc(alias = "gweather_info_get_value_temp")]
    #[doc(alias = "get_value_temp")]
    pub fn value_temp(&self, unit: TemperatureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_temp(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherTemperatureUnit
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the maximum temperature value
    #[doc(alias = "gweather_info_get_value_temp_max")]
    #[doc(alias = "get_value_temp_max")]
    pub fn value_temp_max(&self, unit: TemperatureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_temp_max(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherTemperatureUnit
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the minimum temperature value
    #[doc(alias = "gweather_info_get_value_temp_min")]
    #[doc(alias = "get_value_temp_min")]
    pub fn value_temp_min(&self, unit: TemperatureUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_temp_min(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// Note that @value may be 0 if @self has not yet been updated.
    ///
    /// # Returns
    ///
    /// TRUE is @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// the time @self was last updated
    #[doc(alias = "gweather_info_get_value_update")]
    #[doc(alias = "get_value_update")]
    pub fn value_update(&self) -> Option<libc::c_long> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_update(self.to_glib_none().0, value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherDistanceUnit
    ///
    /// # Returns
    ///
    /// TRUE if @value is valid, FALSE otherwise.
    ///
    /// ## `value`
    /// forecasted visibility, expressed in @unit
    #[doc(alias = "gweather_info_get_value_visibility")]
    #[doc(alias = "get_value_visibility")]
    pub fn value_visibility(&self, unit: DistanceUnit) -> Option<f64> {
        unsafe {
            let mut value = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_visibility(self.to_glib_none().0, unit.into_glib(), value.as_mut_ptr()));
            if ret { Some(value.assume_init()) } else { None }
        }
    }

    /// ## `unit`
    /// the desired unit, as a #GWeatherSpeedUnit
    ///
    /// # Returns
    ///
    /// TRUE if @speed and @direction are valid, FALSE otherwise.
    ///
    /// ## `speed`
    /// forecasted wind speed
    ///
    /// ## `direction`
    /// forecasted wind direction
    #[doc(alias = "gweather_info_get_value_wind")]
    #[doc(alias = "get_value_wind")]
    pub fn value_wind(&self, unit: SpeedUnit) -> Option<(f64, WindDirection)> {
        unsafe {
            let mut speed = mem::MaybeUninit::uninit();
            let mut direction = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gweather_info_get_value_wind(self.to_glib_none().0, unit.into_glib(), speed.as_mut_ptr(), direction.as_mut_ptr()));
            if ret { Some((speed.assume_init(), from_glib(direction.assume_init()))) } else { None }
        }
    }

    #[doc(alias = "gweather_info_get_visibility")]
    #[doc(alias = "get_visibility")]
    pub fn visibility(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_visibility(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// a summary for current weather conditions.
    #[doc(alias = "gweather_info_get_weather_summary")]
    #[doc(alias = "get_weather_summary")]
    pub fn weather_summary(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_weather_summary(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_get_wind")]
    #[doc(alias = "get_wind")]
    pub fn wind(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gweather_info_get_wind(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// Whether it is daytime (that is, if the sun is visible)
    ///   or not at the location and the point of time referred by @self.
    ///   This is mostly equivalent to comparing the return value
    ///   of gweather_info_get_value_sunrise() and
    ///   gweather_info_get_value_sunset(), but it accounts also
    ///   for midnight sun and polar night, for locations within
    ///   the Artic and Antartic circles.
    #[doc(alias = "gweather_info_is_daytime")]
    pub fn is_daytime(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_info_is_daytime(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_is_valid")]
    pub fn is_valid(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_info_is_valid(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_network_error")]
    pub fn network_error(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_info_network_error(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_info_next_sun_event")]
    pub fn next_sun_event(&self) -> i32 {
        unsafe {
            ffi::gweather_info_next_sun_event(self.to_glib_none().0)
        }
    }

    /// Sets the [application ID](https://docs.flatpak.org/en/latest/conventions.html#application-ids)
    /// of the application fetching the weather. It is a requirement
    /// for using any of the online weather providers.
    ///
    /// If the application uses #GApplication, then the application ID
    /// will be automatically filled in.
    /// ## `application_id`
    /// the application ID to set
    #[doc(alias = "gweather_info_set_application_id")]
    pub fn set_application_id(&self, application_id: &str) {
        unsafe {
            ffi::gweather_info_set_application_id(self.to_glib_none().0, application_id.to_glib_none().0);
        }
    }

    /// Sets the contact information for the application fetching the
    /// weather. It is a requirement for using any of the online
    /// weather providers as it allows API providers to contact application
    /// developers in case of terms of use breaches.
    ///
    /// The contact information should be an email address, or the full
    /// URL to an online contact form which weather providers can use
    /// to contact the application developer. Avoid using bug tracker
    /// URLs which require creating accounts.
    /// ## `contact_info`
    /// the contact information for the application
    #[doc(alias = "gweather_info_set_contact_info")]
    pub fn set_contact_info(&self, contact_info: &str) {
        unsafe {
            ffi::gweather_info_set_contact_info(self.to_glib_none().0, contact_info.to_glib_none().0);
        }
    }

    /// Sets the enabled providers for fetching the weather. Note
    /// that it is up to the application developer to make sure that
    /// the terms of use for each service are respected.
    ///
    /// Online providers will not be enabled if the application ID is
    /// not set to a valid value.
    /// ## `providers`
    /// a bitmask of #GWeatherProvider
    #[doc(alias = "gweather_info_set_enabled_providers")]
    pub fn set_enabled_providers(&self, providers: Provider) {
        unsafe {
            ffi::gweather_info_set_enabled_providers(self.to_glib_none().0, providers.into_glib());
        }
    }

    /// Changes the location of the weather report.
    ///
    /// Note that this will clear any forecast or current conditions, and
    /// you must call [`update()`][Self::update()] to obtain the new data.
    /// ## `location`
    /// a location for which weather is desired
    #[doc(alias = "gweather_info_set_location")]
    pub fn set_location(&self, location: Option<&Location>) {
        unsafe {
            ffi::gweather_info_set_location(self.to_glib_none().0, location.to_glib_none().0);
        }
    }

    /// Ensures that any data cached from the network is stored to disk.
    /// Calling this is not necessary, as the cache will be saved when
    /// the last reference to a #GWeatherInfo will be dropped.
    /// On the other hand, it must be called if there is any chance that
    /// the application will be closed without unreffing all objects, such
    /// as when using a language binding that employs a GC.
    #[doc(alias = "gweather_info_store_cache")]
    pub fn store_cache() {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gweather_info_store_cache();
        }
    }

    /// This signal is emitted after the initial fetch of the weather
    /// data from upstream services, and after every successful call
    /// to [`update()`][Self::update()].
    #[doc(alias = "updated")]
    pub fn connect_updated<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn updated_trampoline<F: Fn(&Info) + 'static>(this: *mut ffi::GWeatherInfo, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"updated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(updated_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "application-id")]
    pub fn connect_application_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_application_id_trampoline<F: Fn(&Info) + 'static>(this: *mut ffi::GWeatherInfo, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::application-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_application_id_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "contact-info")]
    pub fn connect_contact_info_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_contact_info_trampoline<F: Fn(&Info) + 'static>(this: *mut ffi::GWeatherInfo, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::contact-info\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_contact_info_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "enabled-providers")]
    pub fn connect_enabled_providers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_enabled_providers_trampoline<F: Fn(&Info) + 'static>(this: *mut ffi::GWeatherInfo, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::enabled-providers\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_enabled_providers_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "location")]
    pub fn connect_location_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_location_trampoline<F: Fn(&Info) + 'static>(this: *mut ffi::GWeatherInfo, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::location\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_location_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl Default for Info {
                     fn default() -> Self {
                         glib::object::Object::new::<Self>(&[])
                            .expect("Can't construct Info object with default parameters")
                     }
                 }

#[derive(Clone, Default)]
// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Info`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct InfoBuilder {
    application_id: Option<String>,
    contact_info: Option<String>,
    enabled_providers: Option<Provider>,
    location: Option<Location>,
}

impl InfoBuilder {
    // rustdoc-stripper-ignore-next
    /// Create a new [`InfoBuilder`].
    pub fn new() -> Self {
        Self::default()
    }


    // rustdoc-stripper-ignore-next
    /// Build the [`Info`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Info {
        let mut properties: Vec<(&str, &dyn ToValue)> = vec![];
if let Some(ref application_id) = self.application_id {
                properties.push(("application-id", application_id));
            }
if let Some(ref contact_info) = self.contact_info {
                properties.push(("contact-info", contact_info));
            }
if let Some(ref enabled_providers) = self.enabled_providers {
                properties.push(("enabled-providers", enabled_providers));
            }
if let Some(ref location) = self.location {
                properties.push(("location", location));
            }
        glib::Object::new::<Info>(&properties)
                .expect("Failed to create an instance of Info")

    }

    /// A unique identifier, typically in the form of reverse DNS notation,
    /// for the application that is querying the weather information.
    ///
    /// Weather providers require this information.
    pub fn application_id(mut self, application_id: &str) -> Self {
        self.application_id = Some(application_id.to_string());
        self
    }

    /// An email address or any other contact form URL.
    ///
    /// Weather providers require this information.
    pub fn contact_info(mut self, contact_info: &str) -> Self {
        self.contact_info = Some(contact_info.to_string());
        self
    }

    /// The enabled weather providers.
    pub fn enabled_providers(mut self, enabled_providers: Provider) -> Self {
        self.enabled_providers = Some(enabled_providers);
        self
    }

    /// The location of the weather information.
    pub fn location(mut self, location: &Location) -> Self {
        self.location = Some(location.clone());
        self
    }
}

impl fmt::Display for Info {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Info")
    }
}
