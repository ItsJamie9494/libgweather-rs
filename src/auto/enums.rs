// This file was generated by gir (https://github.com/gtk-rs/gir)
// from 
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::FormatOptions;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::ffi::CStr;
use std::fmt;

/// The current or forecasted significant phenomenon.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherConditionPhenomenon")]
pub enum ConditionPhenomenon {
    /// value not available
    #[doc(alias = "GWEATHER_PHENOMENON_INVALID")]
    Invalid,
    /// no significant phenomenon
    #[doc(alias = "GWEATHER_PHENOMENON_NONE")]
    None,
    #[doc(alias = "GWEATHER_PHENOMENON_DRIZZLE")]
    Drizzle,
    #[doc(alias = "GWEATHER_PHENOMENON_RAIN")]
    Rain,
    #[doc(alias = "GWEATHER_PHENOMENON_SNOW")]
    Snow,
    #[doc(alias = "GWEATHER_PHENOMENON_SNOW_GRAINS")]
    SnowGrains,
    #[doc(alias = "GWEATHER_PHENOMENON_ICE_CRYSTALS")]
    IceCrystals,
    #[doc(alias = "GWEATHER_PHENOMENON_ICE_PELLETS")]
    IcePellets,
    #[doc(alias = "GWEATHER_PHENOMENON_HAIL")]
    Hail,
    #[doc(alias = "GWEATHER_PHENOMENON_SMALL_HAIL")]
    SmallHail,
    #[doc(alias = "GWEATHER_PHENOMENON_UNKNOWN_PRECIPITATION")]
    UnknownPrecipitation,
    #[doc(alias = "GWEATHER_PHENOMENON_MIST")]
    Mist,
    #[doc(alias = "GWEATHER_PHENOMENON_FOG")]
    Fog,
    #[doc(alias = "GWEATHER_PHENOMENON_SMOKE")]
    Smoke,
    #[doc(alias = "GWEATHER_PHENOMENON_VOLCANIC_ASH")]
    VolcanicAsh,
    #[doc(alias = "GWEATHER_PHENOMENON_SAND")]
    Sand,
    #[doc(alias = "GWEATHER_PHENOMENON_HAZE")]
    Haze,
    #[doc(alias = "GWEATHER_PHENOMENON_SPRAY")]
    Spray,
    #[doc(alias = "GWEATHER_PHENOMENON_DUST")]
    Dust,
    #[doc(alias = "GWEATHER_PHENOMENON_SQUALL")]
    Squall,
    #[doc(alias = "GWEATHER_PHENOMENON_SANDSTORM")]
    Sandstorm,
    #[doc(alias = "GWEATHER_PHENOMENON_DUSTSTORM")]
    Duststorm,
    #[doc(alias = "GWEATHER_PHENOMENON_FUNNEL_CLOUD")]
    FunnelCloud,
    #[doc(alias = "GWEATHER_PHENOMENON_TORNADO")]
    Tornado,
    #[doc(alias = "GWEATHER_PHENOMENON_DUST_WHIRLS")]
    DustWhirls,
    #[doc(alias = "GWEATHER_PHENOMENON_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConditionPhenomenon {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ConditionPhenomenon::{}", match *self {
            Self::Invalid => "Invalid",
            Self::None => "None",
            Self::Drizzle => "Drizzle",
            Self::Rain => "Rain",
            Self::Snow => "Snow",
            Self::SnowGrains => "SnowGrains",
            Self::IceCrystals => "IceCrystals",
            Self::IcePellets => "IcePellets",
            Self::Hail => "Hail",
            Self::SmallHail => "SmallHail",
            Self::UnknownPrecipitation => "UnknownPrecipitation",
            Self::Mist => "Mist",
            Self::Fog => "Fog",
            Self::Smoke => "Smoke",
            Self::VolcanicAsh => "VolcanicAsh",
            Self::Sand => "Sand",
            Self::Haze => "Haze",
            Self::Spray => "Spray",
            Self::Dust => "Dust",
            Self::Squall => "Squall",
            Self::Sandstorm => "Sandstorm",
            Self::Duststorm => "Duststorm",
            Self::FunnelCloud => "FunnelCloud",
            Self::Tornado => "Tornado",
            Self::DustWhirls => "DustWhirls",
            Self::Last => "Last",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ConditionPhenomenon {
    type GlibType = ffi::GWeatherConditionPhenomenon;

    fn into_glib(self) -> ffi::GWeatherConditionPhenomenon {
        match self {
            Self::Invalid => ffi::GWEATHER_PHENOMENON_INVALID,
            Self::None => ffi::GWEATHER_PHENOMENON_NONE,
            Self::Drizzle => ffi::GWEATHER_PHENOMENON_DRIZZLE,
            Self::Rain => ffi::GWEATHER_PHENOMENON_RAIN,
            Self::Snow => ffi::GWEATHER_PHENOMENON_SNOW,
            Self::SnowGrains => ffi::GWEATHER_PHENOMENON_SNOW_GRAINS,
            Self::IceCrystals => ffi::GWEATHER_PHENOMENON_ICE_CRYSTALS,
            Self::IcePellets => ffi::GWEATHER_PHENOMENON_ICE_PELLETS,
            Self::Hail => ffi::GWEATHER_PHENOMENON_HAIL,
            Self::SmallHail => ffi::GWEATHER_PHENOMENON_SMALL_HAIL,
            Self::UnknownPrecipitation => ffi::GWEATHER_PHENOMENON_UNKNOWN_PRECIPITATION,
            Self::Mist => ffi::GWEATHER_PHENOMENON_MIST,
            Self::Fog => ffi::GWEATHER_PHENOMENON_FOG,
            Self::Smoke => ffi::GWEATHER_PHENOMENON_SMOKE,
            Self::VolcanicAsh => ffi::GWEATHER_PHENOMENON_VOLCANIC_ASH,
            Self::Sand => ffi::GWEATHER_PHENOMENON_SAND,
            Self::Haze => ffi::GWEATHER_PHENOMENON_HAZE,
            Self::Spray => ffi::GWEATHER_PHENOMENON_SPRAY,
            Self::Dust => ffi::GWEATHER_PHENOMENON_DUST,
            Self::Squall => ffi::GWEATHER_PHENOMENON_SQUALL,
            Self::Sandstorm => ffi::GWEATHER_PHENOMENON_SANDSTORM,
            Self::Duststorm => ffi::GWEATHER_PHENOMENON_DUSTSTORM,
            Self::FunnelCloud => ffi::GWEATHER_PHENOMENON_FUNNEL_CLOUD,
            Self::Tornado => ffi::GWEATHER_PHENOMENON_TORNADO,
            Self::DustWhirls => ffi::GWEATHER_PHENOMENON_DUST_WHIRLS,
            Self::Last => ffi::GWEATHER_PHENOMENON_LAST,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherConditionPhenomenon> for ConditionPhenomenon {
    unsafe fn from_glib(value: ffi::GWeatherConditionPhenomenon) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_PHENOMENON_INVALID => Self::Invalid,
            ffi::GWEATHER_PHENOMENON_NONE => Self::None,
            ffi::GWEATHER_PHENOMENON_DRIZZLE => Self::Drizzle,
            ffi::GWEATHER_PHENOMENON_RAIN => Self::Rain,
            ffi::GWEATHER_PHENOMENON_SNOW => Self::Snow,
            ffi::GWEATHER_PHENOMENON_SNOW_GRAINS => Self::SnowGrains,
            ffi::GWEATHER_PHENOMENON_ICE_CRYSTALS => Self::IceCrystals,
            ffi::GWEATHER_PHENOMENON_ICE_PELLETS => Self::IcePellets,
            ffi::GWEATHER_PHENOMENON_HAIL => Self::Hail,
            ffi::GWEATHER_PHENOMENON_SMALL_HAIL => Self::SmallHail,
            ffi::GWEATHER_PHENOMENON_UNKNOWN_PRECIPITATION => Self::UnknownPrecipitation,
            ffi::GWEATHER_PHENOMENON_MIST => Self::Mist,
            ffi::GWEATHER_PHENOMENON_FOG => Self::Fog,
            ffi::GWEATHER_PHENOMENON_SMOKE => Self::Smoke,
            ffi::GWEATHER_PHENOMENON_VOLCANIC_ASH => Self::VolcanicAsh,
            ffi::GWEATHER_PHENOMENON_SAND => Self::Sand,
            ffi::GWEATHER_PHENOMENON_HAZE => Self::Haze,
            ffi::GWEATHER_PHENOMENON_SPRAY => Self::Spray,
            ffi::GWEATHER_PHENOMENON_DUST => Self::Dust,
            ffi::GWEATHER_PHENOMENON_SQUALL => Self::Squall,
            ffi::GWEATHER_PHENOMENON_SANDSTORM => Self::Sandstorm,
            ffi::GWEATHER_PHENOMENON_DUSTSTORM => Self::Duststorm,
            ffi::GWEATHER_PHENOMENON_FUNNEL_CLOUD => Self::FunnelCloud,
            ffi::GWEATHER_PHENOMENON_TORNADO => Self::Tornado,
            ffi::GWEATHER_PHENOMENON_DUST_WHIRLS => Self::DustWhirls,
            ffi::GWEATHER_PHENOMENON_LAST => Self::Last,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ConditionPhenomenon {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_phenomenon_get_type()) }
    }
}

impl glib::value::ValueType for ConditionPhenomenon {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConditionPhenomenon {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConditionPhenomenon {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// An additional modifier applied to a #GWeatherConditionPhenomenon to
/// describe the current or forecasted weather conditions.
///
/// The exact meaning of each qualifier is described at
/// http://www.weather.com/glossary/ and
/// http://www.crh.noaa.gov/arx/wx.tbl.php
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherConditionQualifier")]
pub enum ConditionQualifier {
    /// value not available
    #[doc(alias = "GWEATHER_QUALIFIER_INVALID")]
    Invalid,
    /// no qualifier for the phenomenon
    #[doc(alias = "GWEATHER_QUALIFIER_NONE")]
    None,
    /// phenomenon happening in the proximity of the
    ///   location, not in the actual location
    #[doc(alias = "GWEATHER_QUALIFIER_VICINITY")]
    Vicinity,
    /// phenomenon is light or predicted to be light
    #[doc(alias = "GWEATHER_QUALIFIER_LIGHT")]
    Light,
    /// phenomenon is moderate or predicted to be
    ///   moderate
    #[doc(alias = "GWEATHER_QUALIFIER_MODERATE")]
    Moderate,
    /// phenomenon is heavy or predicted to be heavy
    #[doc(alias = "GWEATHER_QUALIFIER_HEAVY")]
    Heavy,
    /// shallow fog (only valid with
    ///   [`ConditionPhenomenon::Fog`][crate::ConditionPhenomenon::Fog])
    #[doc(alias = "GWEATHER_QUALIFIER_SHALLOW")]
    Shallow,
    /// patches of fog (only valid with
    ///   [`ConditionPhenomenon::Fog`][crate::ConditionPhenomenon::Fog])
    #[doc(alias = "GWEATHER_QUALIFIER_PATCHES")]
    Patches,
    /// partial fog (only valid with
    ///   [`ConditionPhenomenon::Fog`][crate::ConditionPhenomenon::Fog])
    #[doc(alias = "GWEATHER_QUALIFIER_PARTIAL")]
    Partial,
    /// phenomenon will be a thunderstorm and/or
    ///   will include lightning
    #[doc(alias = "GWEATHER_QUALIFIER_THUNDERSTORM")]
    Thunderstorm,
    /// phenomenon is blowing (valid with
    ///   [`ConditionPhenomenon::Snow`][crate::ConditionPhenomenon::Snow], [`ConditionPhenomenon::Sand`][crate::ConditionPhenomenon::Sand],
    ///   [`ConditionPhenomenon::Spray`][crate::ConditionPhenomenon::Spray], [`ConditionPhenomenon::Dust`][crate::ConditionPhenomenon::Dust])
    #[doc(alias = "GWEATHER_QUALIFIER_BLOWING")]
    Blowing,
    /// phenomenon is heavy and involves showers
    #[doc(alias = "GWEATHER_QUALIFIER_SHOWERS")]
    Showers,
    /// phenomenon is moving across (valid with
    ///   [`ConditionPhenomenon::Sand`][crate::ConditionPhenomenon::Sand] and [`ConditionPhenomenon::Dust`][crate::ConditionPhenomenon::Dust])
    #[doc(alias = "GWEATHER_QUALIFIER_DRIFTING")]
    Drifting,
    /// phenomenon is freezing and involves ice
    #[doc(alias = "GWEATHER_QUALIFIER_FREEZING")]
    Freezing,
    /// maximum value of the enumeration
    #[doc(alias = "GWEATHER_QUALIFIER_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConditionQualifier {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ConditionQualifier::{}", match *self {
            Self::Invalid => "Invalid",
            Self::None => "None",
            Self::Vicinity => "Vicinity",
            Self::Light => "Light",
            Self::Moderate => "Moderate",
            Self::Heavy => "Heavy",
            Self::Shallow => "Shallow",
            Self::Patches => "Patches",
            Self::Partial => "Partial",
            Self::Thunderstorm => "Thunderstorm",
            Self::Blowing => "Blowing",
            Self::Showers => "Showers",
            Self::Drifting => "Drifting",
            Self::Freezing => "Freezing",
            Self::Last => "Last",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ConditionQualifier {
    type GlibType = ffi::GWeatherConditionQualifier;

    fn into_glib(self) -> ffi::GWeatherConditionQualifier {
        match self {
            Self::Invalid => ffi::GWEATHER_QUALIFIER_INVALID,
            Self::None => ffi::GWEATHER_QUALIFIER_NONE,
            Self::Vicinity => ffi::GWEATHER_QUALIFIER_VICINITY,
            Self::Light => ffi::GWEATHER_QUALIFIER_LIGHT,
            Self::Moderate => ffi::GWEATHER_QUALIFIER_MODERATE,
            Self::Heavy => ffi::GWEATHER_QUALIFIER_HEAVY,
            Self::Shallow => ffi::GWEATHER_QUALIFIER_SHALLOW,
            Self::Patches => ffi::GWEATHER_QUALIFIER_PATCHES,
            Self::Partial => ffi::GWEATHER_QUALIFIER_PARTIAL,
            Self::Thunderstorm => ffi::GWEATHER_QUALIFIER_THUNDERSTORM,
            Self::Blowing => ffi::GWEATHER_QUALIFIER_BLOWING,
            Self::Showers => ffi::GWEATHER_QUALIFIER_SHOWERS,
            Self::Drifting => ffi::GWEATHER_QUALIFIER_DRIFTING,
            Self::Freezing => ffi::GWEATHER_QUALIFIER_FREEZING,
            Self::Last => ffi::GWEATHER_QUALIFIER_LAST,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherConditionQualifier> for ConditionQualifier {
    unsafe fn from_glib(value: ffi::GWeatherConditionQualifier) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_QUALIFIER_INVALID => Self::Invalid,
            ffi::GWEATHER_QUALIFIER_NONE => Self::None,
            ffi::GWEATHER_QUALIFIER_VICINITY => Self::Vicinity,
            ffi::GWEATHER_QUALIFIER_LIGHT => Self::Light,
            ffi::GWEATHER_QUALIFIER_MODERATE => Self::Moderate,
            ffi::GWEATHER_QUALIFIER_HEAVY => Self::Heavy,
            ffi::GWEATHER_QUALIFIER_SHALLOW => Self::Shallow,
            ffi::GWEATHER_QUALIFIER_PATCHES => Self::Patches,
            ffi::GWEATHER_QUALIFIER_PARTIAL => Self::Partial,
            ffi::GWEATHER_QUALIFIER_THUNDERSTORM => Self::Thunderstorm,
            ffi::GWEATHER_QUALIFIER_BLOWING => Self::Blowing,
            ffi::GWEATHER_QUALIFIER_SHOWERS => Self::Showers,
            ffi::GWEATHER_QUALIFIER_DRIFTING => Self::Drifting,
            ffi::GWEATHER_QUALIFIER_FREEZING => Self::Freezing,
            ffi::GWEATHER_QUALIFIER_LAST => Self::Last,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ConditionQualifier {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_qualifier_get_type()) }
    }
}

impl glib::value::ValueType for ConditionQualifier {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ConditionQualifier {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConditionQualifier {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The measure unit to use for sky visibility values, when retrieved
/// by gweather_info_get_value_visibility().
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherDistanceUnit")]
pub enum DistanceUnit {
    /// invalid unit
    #[doc(alias = "GWEATHER_DISTANCE_UNIT_INVALID")]
    Invalid,
    /// the user preferred distance unit
    #[doc(alias = "GWEATHER_DISTANCE_UNIT_DEFAULT")]
    Default,
    /// meters
    #[doc(alias = "GWEATHER_DISTANCE_UNIT_METERS")]
    Meters,
    /// kilometers (= 1000 meters)
    #[doc(alias = "GWEATHER_DISTANCE_UNIT_KM")]
    Km,
    /// miles
    #[doc(alias = "GWEATHER_DISTANCE_UNIT_MILES")]
    Miles,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DistanceUnit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "DistanceUnit::{}", match *self {
            Self::Invalid => "Invalid",
            Self::Default => "Default",
            Self::Meters => "Meters",
            Self::Km => "Km",
            Self::Miles => "Miles",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for DistanceUnit {
    type GlibType = ffi::GWeatherDistanceUnit;

    fn into_glib(self) -> ffi::GWeatherDistanceUnit {
        match self {
            Self::Invalid => ffi::GWEATHER_DISTANCE_UNIT_INVALID,
            Self::Default => ffi::GWEATHER_DISTANCE_UNIT_DEFAULT,
            Self::Meters => ffi::GWEATHER_DISTANCE_UNIT_METERS,
            Self::Km => ffi::GWEATHER_DISTANCE_UNIT_KM,
            Self::Miles => ffi::GWEATHER_DISTANCE_UNIT_MILES,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherDistanceUnit> for DistanceUnit {
    unsafe fn from_glib(value: ffi::GWeatherDistanceUnit) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_DISTANCE_UNIT_INVALID => Self::Invalid,
            ffi::GWEATHER_DISTANCE_UNIT_DEFAULT => Self::Default,
            ffi::GWEATHER_DISTANCE_UNIT_METERS => Self::Meters,
            ffi::GWEATHER_DISTANCE_UNIT_KM => Self::Km,
            ffi::GWEATHER_DISTANCE_UNIT_MILES => Self::Miles,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for DistanceUnit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_distance_unit_get_type()) }
    }
}

impl glib::value::ValueType for DistanceUnit {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DistanceUnit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DistanceUnit {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The size/scope of a particular [`Location`][crate::Location].
///
/// Locations form a hierarchy, with a `GWEATHER_LOCATION_WORLD` location
/// at the top, divided into regions or countries, and so on.
///
/// Countries may or may not be divided into "adm1"s, and "adm1"s may or
/// may not be divided into "adm2"s. A city will have at least one, and
/// possibly several, weather stations inside it. Weather stations will
/// never appear outside of cities.
///
/// Building a database with [`Location::world()`][crate::Location::world()] will never
/// create detached instances, but deserializing might.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherLocationLevel")]
pub enum LocationLevel {
    /// A location representing the entire world
    #[doc(alias = "GWEATHER_LOCATION_WORLD")]
    World,
    /// A location representing a continent or other
    ///   top-level region
    #[doc(alias = "GWEATHER_LOCATION_REGION")]
    Region,
    /// A location representing a "country" (or other
    ///   geographic unit that has an ISO-3166 country code)
    #[doc(alias = "GWEATHER_LOCATION_COUNTRY")]
    Country,
    /// A location representing a "first-level
    ///   administrative division"; ie, a state, province, or similar division
    #[doc(alias = "GWEATHER_LOCATION_ADM1")]
    Adm1,
    /// A location representing a city
    #[doc(alias = "GWEATHER_LOCATION_CITY")]
    City,
    /// A location representing a weather
    ///   station
    #[doc(alias = "GWEATHER_LOCATION_WEATHER_STATION")]
    WeatherStation,
    /// A location that is detached from the database,
    ///   for example because it was loaded from external storage and could not be
    ///   fully recovered. The parent of this location is the nearest weather
    ///   station
    #[doc(alias = "GWEATHER_LOCATION_DETACHED")]
    Detached,
    /// A location representing a named or
    ///   special timezone in the world, such as UTC
    #[doc(alias = "GWEATHER_LOCATION_NAMED_TIMEZONE")]
    NamedTimezone,
#[doc(hidden)]
    __Unknown(i32),
}

impl LocationLevel {
    pub fn to_str<'a>(self) -> &'a str {
        unsafe {
            CStr::from_ptr(
                ffi::gweather_location_level_to_string(self.into_glib())
                    .as_ref()
                    .expect("gweather_location_level_to_string returned NULL"),
            )
            .to_str()
            .expect("gweather_location_level_to_string returned an invalid string")
        }
    }
}

impl fmt::Display for LocationLevel {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}

#[doc(hidden)]
impl IntoGlib for LocationLevel {
    type GlibType = ffi::GWeatherLocationLevel;

    fn into_glib(self) -> ffi::GWeatherLocationLevel {
        match self {
            Self::World => ffi::GWEATHER_LOCATION_WORLD,
            Self::Region => ffi::GWEATHER_LOCATION_REGION,
            Self::Country => ffi::GWEATHER_LOCATION_COUNTRY,
            Self::Adm1 => ffi::GWEATHER_LOCATION_ADM1,
            Self::City => ffi::GWEATHER_LOCATION_CITY,
            Self::WeatherStation => ffi::GWEATHER_LOCATION_WEATHER_STATION,
            Self::Detached => ffi::GWEATHER_LOCATION_DETACHED,
            Self::NamedTimezone => ffi::GWEATHER_LOCATION_NAMED_TIMEZONE,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherLocationLevel> for LocationLevel {
    unsafe fn from_glib(value: ffi::GWeatherLocationLevel) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_LOCATION_WORLD => Self::World,
            ffi::GWEATHER_LOCATION_REGION => Self::Region,
            ffi::GWEATHER_LOCATION_COUNTRY => Self::Country,
            ffi::GWEATHER_LOCATION_ADM1 => Self::Adm1,
            ffi::GWEATHER_LOCATION_CITY => Self::City,
            ffi::GWEATHER_LOCATION_WEATHER_STATION => Self::WeatherStation,
            ffi::GWEATHER_LOCATION_DETACHED => Self::Detached,
            ffi::GWEATHER_LOCATION_NAMED_TIMEZONE => Self::NamedTimezone,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for LocationLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_location_level_get_type()) }
    }
}

impl glib::value::ValueType for LocationLevel {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for LocationLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LocationLevel {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The measure unit to use for atmospheric pressure values, when
/// retrieved by gweather_info_get_value_pressure().
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherPressureUnit")]
pub enum PressureUnit {
    /// invalid unit
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_INVALID")]
    Invalid,
    /// the user preferred pressure unit
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_DEFAULT")]
    Default,
    /// kiloPascal (* 10^3 Pa)
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_KPA")]
    Kpa,
    /// hectoPascal (* 10^2 Pa); also known
    ///   as millibars, but formatted differently
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_HPA")]
    Hpa,
    /// millibars; same as [`Hpa`][Self::Hpa]
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_MB")]
    Mb,
    /// millimeters of mercury
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_MM_HG")]
    MmHg,
    /// inches of mercury
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_INCH_HG")]
    InchHg,
    /// atmospheres
    #[doc(alias = "GWEATHER_PRESSURE_UNIT_ATM")]
    Atm,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PressureUnit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PressureUnit::{}", match *self {
            Self::Invalid => "Invalid",
            Self::Default => "Default",
            Self::Kpa => "Kpa",
            Self::Hpa => "Hpa",
            Self::Mb => "Mb",
            Self::MmHg => "MmHg",
            Self::InchHg => "InchHg",
            Self::Atm => "Atm",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for PressureUnit {
    type GlibType = ffi::GWeatherPressureUnit;

    fn into_glib(self) -> ffi::GWeatherPressureUnit {
        match self {
            Self::Invalid => ffi::GWEATHER_PRESSURE_UNIT_INVALID,
            Self::Default => ffi::GWEATHER_PRESSURE_UNIT_DEFAULT,
            Self::Kpa => ffi::GWEATHER_PRESSURE_UNIT_KPA,
            Self::Hpa => ffi::GWEATHER_PRESSURE_UNIT_HPA,
            Self::Mb => ffi::GWEATHER_PRESSURE_UNIT_MB,
            Self::MmHg => ffi::GWEATHER_PRESSURE_UNIT_MM_HG,
            Self::InchHg => ffi::GWEATHER_PRESSURE_UNIT_INCH_HG,
            Self::Atm => ffi::GWEATHER_PRESSURE_UNIT_ATM,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherPressureUnit> for PressureUnit {
    unsafe fn from_glib(value: ffi::GWeatherPressureUnit) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_PRESSURE_UNIT_INVALID => Self::Invalid,
            ffi::GWEATHER_PRESSURE_UNIT_DEFAULT => Self::Default,
            ffi::GWEATHER_PRESSURE_UNIT_KPA => Self::Kpa,
            ffi::GWEATHER_PRESSURE_UNIT_HPA => Self::Hpa,
            ffi::GWEATHER_PRESSURE_UNIT_MB => Self::Mb,
            ffi::GWEATHER_PRESSURE_UNIT_MM_HG => Self::MmHg,
            ffi::GWEATHER_PRESSURE_UNIT_INCH_HG => Self::InchHg,
            ffi::GWEATHER_PRESSURE_UNIT_ATM => Self::Atm,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for PressureUnit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_pressure_unit_get_type()) }
    }
}

impl glib::value::ValueType for PressureUnit {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PressureUnit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PressureUnit {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The sky and cloud visibility. In general it is discouraged to
/// use this value directly to compute the forecast icon: applications
/// should instead use gweather_info_get_icon_name() or
/// gweather_info_get_symbolic_icon_name().
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherSky")]
pub enum Sky {
    /// value not available
    #[doc(alias = "GWEATHER_SKY_INVALID")]
    Invalid,
    /// sky completely clear, no clouds visible
    #[doc(alias = "GWEATHER_SKY_CLEAR")]
    Clear,
    /// sky mostly clear, few clouds
    #[doc(alias = "GWEATHER_SKY_BROKEN")]
    Broken,
    /// sky mostly clear, patches of clouds
    #[doc(alias = "GWEATHER_SKY_SCATTERED")]
    Scattered,
    /// few clouds, sky cloudy but patches of sky visible
    #[doc(alias = "GWEATHER_SKY_FEW")]
    Few,
    /// sky completely clouded, sun not visible
    #[doc(alias = "GWEATHER_SKY_OVERCAST")]
    Overcast,
    /// the maximum value for the enumeration
    #[doc(alias = "GWEATHER_SKY_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl Sky {
    pub fn to_str<'a>(self) -> &'a str {
        unsafe {
            CStr::from_ptr(
                ffi::gweather_sky_to_string(self.into_glib())
                    .as_ref()
                    .expect("gweather_sky_to_string returned NULL"),
            )
            .to_str()
            .expect("gweather_sky_to_string returned an invalid string")
        }
    }

    #[doc(alias = "gweather_sky_to_string_full")]
    pub fn to_string_full(self, options: FormatOptions) -> glib::GString {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gweather_sky_to_string_full(self.into_glib(), options.into_glib()))
        }
    }
}

impl fmt::Display for Sky {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}

#[doc(hidden)]
impl IntoGlib for Sky {
    type GlibType = ffi::GWeatherSky;

    fn into_glib(self) -> ffi::GWeatherSky {
        match self {
            Self::Invalid => ffi::GWEATHER_SKY_INVALID,
            Self::Clear => ffi::GWEATHER_SKY_CLEAR,
            Self::Broken => ffi::GWEATHER_SKY_BROKEN,
            Self::Scattered => ffi::GWEATHER_SKY_SCATTERED,
            Self::Few => ffi::GWEATHER_SKY_FEW,
            Self::Overcast => ffi::GWEATHER_SKY_OVERCAST,
            Self::Last => ffi::GWEATHER_SKY_LAST,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherSky> for Sky {
    unsafe fn from_glib(value: ffi::GWeatherSky) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_SKY_INVALID => Self::Invalid,
            ffi::GWEATHER_SKY_CLEAR => Self::Clear,
            ffi::GWEATHER_SKY_BROKEN => Self::Broken,
            ffi::GWEATHER_SKY_SCATTERED => Self::Scattered,
            ffi::GWEATHER_SKY_FEW => Self::Few,
            ffi::GWEATHER_SKY_OVERCAST => Self::Overcast,
            ffi::GWEATHER_SKY_LAST => Self::Last,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for Sky {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_sky_get_type()) }
    }
}

impl glib::value::ValueType for Sky {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Sky {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Sky {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The measure unit to use for wind speed values, when retrieved by
/// gweather_info_get_value_wind().
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherSpeedUnit")]
pub enum SpeedUnit {
    /// invalid unit
    #[doc(alias = "GWEATHER_SPEED_UNIT_INVALID")]
    Invalid,
    /// the user preferred speed unit
    #[doc(alias = "GWEATHER_SPEED_UNIT_DEFAULT")]
    Default,
    /// meters per second
    #[doc(alias = "GWEATHER_SPEED_UNIT_MS")]
    Ms,
    /// kilometers per hour
    #[doc(alias = "GWEATHER_SPEED_UNIT_KPH")]
    Kph,
    /// miles per hour
    #[doc(alias = "GWEATHER_SPEED_UNIT_MPH")]
    Mph,
    /// knots
    #[doc(alias = "GWEATHER_SPEED_UNIT_KNOTS")]
    Knots,
    /// Beaufort scale
    #[doc(alias = "GWEATHER_SPEED_UNIT_BFT")]
    Bft,
#[doc(hidden)]
    __Unknown(i32),
}

impl SpeedUnit {
    pub fn to_str<'a>(self) -> &'a str {
        unsafe {
            CStr::from_ptr(
                ffi::gweather_speed_unit_to_string(self.into_glib())
                    .as_ref()
                    .expect("gweather_speed_unit_to_string returned NULL"),
            )
            .to_str()
            .expect("gweather_speed_unit_to_string returned an invalid string")
        }
    }
}

impl fmt::Display for SpeedUnit {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}

#[doc(hidden)]
impl IntoGlib for SpeedUnit {
    type GlibType = ffi::GWeatherSpeedUnit;

    fn into_glib(self) -> ffi::GWeatherSpeedUnit {
        match self {
            Self::Invalid => ffi::GWEATHER_SPEED_UNIT_INVALID,
            Self::Default => ffi::GWEATHER_SPEED_UNIT_DEFAULT,
            Self::Ms => ffi::GWEATHER_SPEED_UNIT_MS,
            Self::Kph => ffi::GWEATHER_SPEED_UNIT_KPH,
            Self::Mph => ffi::GWEATHER_SPEED_UNIT_MPH,
            Self::Knots => ffi::GWEATHER_SPEED_UNIT_KNOTS,
            Self::Bft => ffi::GWEATHER_SPEED_UNIT_BFT,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherSpeedUnit> for SpeedUnit {
    unsafe fn from_glib(value: ffi::GWeatherSpeedUnit) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_SPEED_UNIT_INVALID => Self::Invalid,
            ffi::GWEATHER_SPEED_UNIT_DEFAULT => Self::Default,
            ffi::GWEATHER_SPEED_UNIT_MS => Self::Ms,
            ffi::GWEATHER_SPEED_UNIT_KPH => Self::Kph,
            ffi::GWEATHER_SPEED_UNIT_MPH => Self::Mph,
            ffi::GWEATHER_SPEED_UNIT_KNOTS => Self::Knots,
            ffi::GWEATHER_SPEED_UNIT_BFT => Self::Bft,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for SpeedUnit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_speed_unit_get_type()) }
    }
}

impl glib::value::ValueType for SpeedUnit {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SpeedUnit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SpeedUnit {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The measure unit to use for temperature values, when retrieved by
/// the gweather_info_get_value_temp() family of functions.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherTemperatureUnit")]
pub enum TemperatureUnit {
    /// invalid unit
    #[doc(alias = "GWEATHER_TEMP_UNIT_INVALID")]
    Invalid,
    /// the user preferred temperature unit
    #[doc(alias = "GWEATHER_TEMP_UNIT_DEFAULT")]
    Default,
    /// Kelvin (absolute) temperature scale
    #[doc(alias = "GWEATHER_TEMP_UNIT_KELVIN")]
    Kelvin,
    /// Celsius temperature scale
    #[doc(alias = "GWEATHER_TEMP_UNIT_CENTIGRADE")]
    Centigrade,
    /// Fahrenheit temperature scale
    #[doc(alias = "GWEATHER_TEMP_UNIT_FAHRENHEIT")]
    Fahrenheit,
#[doc(hidden)]
    __Unknown(i32),
}

impl TemperatureUnit {
    #[doc(alias = "gweather_temperature_unit_to_real")]
    pub fn to_real(self) -> TemperatureUnit {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gweather_temperature_unit_to_real(self.into_glib()))
        }
    }
}

impl fmt::Display for TemperatureUnit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "TemperatureUnit::{}", match *self {
            Self::Invalid => "Invalid",
            Self::Default => "Default",
            Self::Kelvin => "Kelvin",
            Self::Centigrade => "Centigrade",
            Self::Fahrenheit => "Fahrenheit",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for TemperatureUnit {
    type GlibType = ffi::GWeatherTemperatureUnit;

    fn into_glib(self) -> ffi::GWeatherTemperatureUnit {
        match self {
            Self::Invalid => ffi::GWEATHER_TEMP_UNIT_INVALID,
            Self::Default => ffi::GWEATHER_TEMP_UNIT_DEFAULT,
            Self::Kelvin => ffi::GWEATHER_TEMP_UNIT_KELVIN,
            Self::Centigrade => ffi::GWEATHER_TEMP_UNIT_CENTIGRADE,
            Self::Fahrenheit => ffi::GWEATHER_TEMP_UNIT_FAHRENHEIT,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherTemperatureUnit> for TemperatureUnit {
    unsafe fn from_glib(value: ffi::GWeatherTemperatureUnit) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_TEMP_UNIT_INVALID => Self::Invalid,
            ffi::GWEATHER_TEMP_UNIT_DEFAULT => Self::Default,
            ffi::GWEATHER_TEMP_UNIT_KELVIN => Self::Kelvin,
            ffi::GWEATHER_TEMP_UNIT_CENTIGRADE => Self::Centigrade,
            ffi::GWEATHER_TEMP_UNIT_FAHRENHEIT => Self::Fahrenheit,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for TemperatureUnit {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_temperature_unit_get_type()) }
    }
}

impl glib::value::ValueType for TemperatureUnit {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TemperatureUnit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TemperatureUnit {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

/// The direction of the prevailing wind. Composite values
/// such as north-north-east indicate a direction between the
/// two component value (north and north-east).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GWeatherWindDirection")]
pub enum WindDirection {
    /// value not available
    #[doc(alias = "GWEATHER_WIND_INVALID")]
    Invalid,
    /// variable throughout the day
    #[doc(alias = "GWEATHER_WIND_VARIABLE")]
    Variable,
    /// north
    #[doc(alias = "GWEATHER_WIND_N")]
    N,
    /// north-north-east
    #[doc(alias = "GWEATHER_WIND_NNE")]
    Nne,
    /// north-east
    #[doc(alias = "GWEATHER_WIND_NE")]
    Ne,
    /// east-north-east
    #[doc(alias = "GWEATHER_WIND_ENE")]
    Ene,
    /// east
    #[doc(alias = "GWEATHER_WIND_E")]
    E,
    /// east-south-east
    #[doc(alias = "GWEATHER_WIND_ESE")]
    Ese,
    /// south-east
    #[doc(alias = "GWEATHER_WIND_SE")]
    Se,
    /// south-south-east
    #[doc(alias = "GWEATHER_WIND_SSE")]
    Sse,
    /// south
    #[doc(alias = "GWEATHER_WIND_S")]
    S,
    /// south-south-west
    #[doc(alias = "GWEATHER_WIND_SSW")]
    Ssw,
    /// south-west
    #[doc(alias = "GWEATHER_WIND_SW")]
    Sw,
    /// west-south-west
    #[doc(alias = "GWEATHER_WIND_WSW")]
    Wsw,
    /// west
    #[doc(alias = "GWEATHER_WIND_W")]
    W,
    /// west-north-west
    #[doc(alias = "GWEATHER_WIND_WNW")]
    Wnw,
    /// north-west
    #[doc(alias = "GWEATHER_WIND_NW")]
    Nw,
    /// north-north-west
    #[doc(alias = "GWEATHER_WIND_NNW")]
    Nnw,
    /// maximum value for the enumeration
    #[doc(alias = "GWEATHER_WIND_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl WindDirection {
    pub fn to_str<'a>(self) -> &'a str {
        unsafe {
            CStr::from_ptr(
                ffi::gweather_wind_direction_to_string(self.into_glib())
                    .as_ref()
                    .expect("gweather_wind_direction_to_string returned NULL"),
            )
            .to_str()
            .expect("gweather_wind_direction_to_string returned an invalid string")
        }
    }

    #[doc(alias = "gweather_wind_direction_to_string_full")]
    pub fn to_string_full(self, options: FormatOptions) -> glib::GString {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gweather_wind_direction_to_string_full(self.into_glib(), options.into_glib()))
        }
    }
}

impl fmt::Display for WindDirection {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}

#[doc(hidden)]
impl IntoGlib for WindDirection {
    type GlibType = ffi::GWeatherWindDirection;

    fn into_glib(self) -> ffi::GWeatherWindDirection {
        match self {
            Self::Invalid => ffi::GWEATHER_WIND_INVALID,
            Self::Variable => ffi::GWEATHER_WIND_VARIABLE,
            Self::N => ffi::GWEATHER_WIND_N,
            Self::Nne => ffi::GWEATHER_WIND_NNE,
            Self::Ne => ffi::GWEATHER_WIND_NE,
            Self::Ene => ffi::GWEATHER_WIND_ENE,
            Self::E => ffi::GWEATHER_WIND_E,
            Self::Ese => ffi::GWEATHER_WIND_ESE,
            Self::Se => ffi::GWEATHER_WIND_SE,
            Self::Sse => ffi::GWEATHER_WIND_SSE,
            Self::S => ffi::GWEATHER_WIND_S,
            Self::Ssw => ffi::GWEATHER_WIND_SSW,
            Self::Sw => ffi::GWEATHER_WIND_SW,
            Self::Wsw => ffi::GWEATHER_WIND_WSW,
            Self::W => ffi::GWEATHER_WIND_W,
            Self::Wnw => ffi::GWEATHER_WIND_WNW,
            Self::Nw => ffi::GWEATHER_WIND_NW,
            Self::Nnw => ffi::GWEATHER_WIND_NNW,
            Self::Last => ffi::GWEATHER_WIND_LAST,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GWeatherWindDirection> for WindDirection {
    unsafe fn from_glib(value: ffi::GWeatherWindDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GWEATHER_WIND_INVALID => Self::Invalid,
            ffi::GWEATHER_WIND_VARIABLE => Self::Variable,
            ffi::GWEATHER_WIND_N => Self::N,
            ffi::GWEATHER_WIND_NNE => Self::Nne,
            ffi::GWEATHER_WIND_NE => Self::Ne,
            ffi::GWEATHER_WIND_ENE => Self::Ene,
            ffi::GWEATHER_WIND_E => Self::E,
            ffi::GWEATHER_WIND_ESE => Self::Ese,
            ffi::GWEATHER_WIND_SE => Self::Se,
            ffi::GWEATHER_WIND_SSE => Self::Sse,
            ffi::GWEATHER_WIND_S => Self::S,
            ffi::GWEATHER_WIND_SSW => Self::Ssw,
            ffi::GWEATHER_WIND_SW => Self::Sw,
            ffi::GWEATHER_WIND_WSW => Self::Wsw,
            ffi::GWEATHER_WIND_W => Self::W,
            ffi::GWEATHER_WIND_WNW => Self::Wnw,
            ffi::GWEATHER_WIND_NW => Self::Nw,
            ffi::GWEATHER_WIND_NNW => Self::Nnw,
            ffi::GWEATHER_WIND_LAST => Self::Last,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for WindDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gweather_wind_direction_get_type()) }
    }
}

impl glib::value::ValueType for WindDirection {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for WindDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WindDirection {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

